/*
  ==============================================================================

  Synth-A-Modeler compiler (c++ version)
  Author: Peter Vasil (code), Edgar Berdahl (method)

  ==============================================================================

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software Foundation,
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

*/

#include "../JuceLibraryCode/JuceHeader.h"


typedef Identifier SAMId;
struct MassLinkRef
{
    String massId;
    StringArray linkRefs;
    bool isWithJunction;
};

namespace Ids
{
const Identifier identifier("identifier");
const Identifier startVertex("startVertex");
const Identifier endVertex("endVertex");
const Identifier termination("termination");
const Identifier junction("junction");
const Identifier parameters("parameters");
const Identifier value("value");
};
//int containsMassLinkRef(std::vector<MassLinkRef> mlf, const String& mId)
int containsMassLinkRef(const OwnedArray<MassLinkRef>& mlf, const String& mId)
{
    for (int i = 0; i < mlf.size(); ++i)
    {
        MassLinkRef* m = mlf[i];
        if(m->massId.compare(mId) == 0)
            return i;
    }
    return -1;
}
int showHelp()
{
    std::cout << "Synth-A-Modeler!" << std::endl
        << std::endl
        << "Usage: " << std::endl
        << std::endl
        << " Synth-A-Modeler /path/to/inputfile.mdlx"
        << " /path/to/outputfile.dsp" << std::endl
        << std::endl;

    return 0;
}

static const char* wgL = "L";
static const char* wgR = "R";
static const char* wgLp = "Lp";
static const char* wgRp = "Rp";
static const char* jTO = "TO";
static const char* jOutputs = "Outputs";

String generateDspString(const XmlElement& xml)
{
    String dspContent;

    dspContent << "// This DSP file has been generated by the Synth-A-Modeler compiler.\n";
    dspContent << "import(\"physicalmodeling.lib\");\n\n";

    const XmlElement* faustcode = xml.getChildByName("variables");
    const XmlElement* masses = xml.getChildByName("masses");
    const XmlElement* links = xml.getChildByName("links");
    const XmlElement* waveguides = xml.getChildByName("waveguides");
    const XmlElement* terminations = xml.getChildByName("terminations");
    const XmlElement* junctions = xml.getChildByName("junctions");
    const XmlElement* audioouts = xml.getChildByName("audioobjects");

    ValueTree linkTree;
    ValueTree wgTree;
    ValueTree jTree;
    ValueTree tTree;

    if(links != nullptr)
        linkTree = ValueTree::fromXml(*links);
    if(waveguides != nullptr)
        wgTree = ValueTree::fromXml(*waveguides);
    if(terminations != nullptr)
        tTree = ValueTree::fromXml(*terminations);
    if(junctions != nullptr)
        jTree = ValueTree::fromXml(*junctions);

//    DBG(wgTree.toXmlString());
//    DBG(jTree.toXmlString());
//    DBG(tTree.toXmlString());
    
    int numMasslike = 0;
    int numPorts = 0;
    int numWaveguides = 0;
    String wgTermString;
    String junctString;
    StringArray wgOutputs;
    for (int i = 0; i < wgTree.getNumChildren(); ++i)
    {
        ++numWaveguides;
        ValueTree wg = wgTree.getChild(i);
        ValueTree left = jTree.getChildWithProperty(Ids::identifier,
                                                    wg[Ids::startVertex]);
        ValueTree right;
        if(left.isValid())
        {
            right = tTree.getChildWithProperty(Ids::identifier,
                                               wg[Ids::endVertex]);
        }
        else
        {
            left = tTree.getChildWithProperty(Ids::identifier,wg[Ids::startVertex]);
            right = jTree.getChildWithProperty(Ids::identifier,wg[Ids::endVertex]);
        }
        ValueTree term;
        ValueTree junct;
        StringArray wgSuffixes;
        if(left.getType() == Ids::termination)
        {
            DBG(left.toXmlString());
            DBG(right.toXmlString());
            wgSuffixes.add(wgR);
            wgSuffixes.add(wgL);
            wgSuffixes.add(wgRp);
            wgSuffixes.add(wgLp);

            term = left;
            junct = right;
        }
        else if(left.getType() == Ids::junction)
        {
            DBG(left.toXmlString());
            DBG(right.toXmlString());

            wgSuffixes.add(wgL);
            wgSuffixes.add(wgR);
            wgSuffixes.add(wgLp);
            wgSuffixes.add(wgRp);
            term = right;
            junct = left;
        }

        wgOutputs.add(wg[Ids::identifier].toString() + wgLp);
        wgOutputs.add(wg[Ids::identifier].toString() + wgRp);

        wgTermString << wg[Ids::identifier].toString();
        wgTermString << wgSuffixes[0] << " = " << term[Ids::identifier].toString();

        ValueTree paWg = wg.getChildWithName(Ids::parameters);
        StringArray paWgStrings;
        for (int j = 0; j < paWg.getNumChildren(); ++j)
        {
            paWgStrings.add(paWg.getChild(j)[Ids::value].toString());
        }

        wgTermString << " : ";
        wgTermString << paWgStrings[1];
        wgTermString << ";\n\t";

        wgTermString << term[Ids::identifier].toString();
        wgTermString << " = ";
        wgTermString << wg[Ids::identifier].toString() << wgSuffixes[3];
        wgTermString << " : ";

        ValueTree paTerm = term.getChildWithName(Ids::parameters);
        StringArray paTermStrings;
        for (int j = 0; j < paTerm.getNumChildren(); ++j)
        {
            paTermStrings.add(paTerm.getChild(j)[Ids::value].toString());
        }

        wgTermString << paTermStrings[0];

        junctString << wg[Ids::identifier].toString() << wgSuffixes[1];
        junctString << " = ";
        junctString << junct[Ids::identifier].toString() << jTO;
        junctString << wg[Ids::identifier].toString();
        junctString << " : ";
        junctString << paWgStrings[1];
        junctString << ";\n\t";

        junctString << junct[Ids::identifier].toString() << jTO;
        junctString << wg[Ids::identifier].toString() << " = ";
        junctString << junct[Ids::identifier].toString() << jOutputs;
        junctString << ":(_:!)-";
        junctString << wg[Ids::identifier].toString() << wgSuffixes[2];
        junctString << ";\n\t";

        junctString << junct[Ids::identifier].toString() << jOutputs;
        junctString << " = (0.0, 0.0+";
        junctString << wg[Ids::identifier].toString() << wgSuffixes[2];
        junctString << "*" << paWgStrings[0];
        junctString << ", 0.0+" << paWgStrings[0];
        junctString << " : ";
        // TODO has links?
        if (false)
        {

        }
        else
        {
            junctString << "junctionlink(0.0, 0.0, 0.0, 0.0);\n\t";
        }

        junctString << junct[Ids::identifier].toString();
        junctString << " = ";
        junctString << junct[Ids::identifier].toString() << jOutputs;
        junctString << ":(_:!);\n";

    }

    // Write all faustcode
    forEachXmlChildElementWithTagName(*faustcode, c, "variable")
    {
        dspContent << c->getStringAttribute("identifier");
        dspContent << "=";
        dspContent << c->getStringAttribute("faustCode");
        dspContent << ";\n";
    }
    dspContent << "\n";

    // Get all ma
    OwnedArray<MassLinkRef> massLinkRefs;
    forEachXmlChildElement(*masses, c)
    {
        MassLinkRef* mlf = new MassLinkRef();
        mlf->massId = c->getStringAttribute("identifier");
        StringArray mlfa;
        mlf->linkRefs = mlfa;
        mlf->isWithJunction = false;
        massLinkRefs.add(mlf);
    }


    // Write all link-like objects
    StringArray linkobjects;

    forEachXmlChildElement(*links, c)
    {
        String linkId = c->getStringAttribute("identifier");
        String startVertex = c->getStringAttribute("startVertex");
        String endVertex = c->getStringAttribute("endVertex");
        int sIdx = containsMassLinkRef(massLinkRefs, startVertex);
        if(sIdx >= 0)
            massLinkRefs[sIdx]->linkRefs.add("-"+linkId);

        int eIdx = containsMassLinkRef(massLinkRefs, endVertex);
        if(eIdx >= 0)
            massLinkRefs[eIdx]->linkRefs.add("+"+linkId);

        String tagName = c->getTagName();
        XmlElement* params = c->getChildByName("parameters");
        StringArray paramsStr;
        forEachXmlChildElement(*params, c2)
        {
            paramsStr.add(c2->getStringAttribute("value"));
        }

        String linkLine;
        linkLine << "\t";
        linkLine << linkId;
        linkLine << " = (";

        linkLine << startVertex << "p - ";
        linkLine << endVertex << "p) : ";
        linkLine << tagName << "(";
        linkLine << paramsStr.joinIntoString(",") << ");";
        linkobjects.add(linkLine);
    }
    StringArray massobjects;
    forEachXmlChildElement(*masses, c)
    {
        ++numMasslike;
        String massLine;
        String tagName = c->getTagName();
        massLine << "\t";
        String massName = c->getStringAttribute("identifier");
        massLine << massName << " = (0.0";
        if(tagName.compare("port") == 0)
            ++numPorts;

        int mIdx = containsMassLinkRef(massLinkRefs, massName);
        if(mIdx >= 0)
        {
            if(massLinkRefs[mIdx]->linkRefs.size() > 0)
            {
                massLine << massLinkRefs[mIdx]->linkRefs.joinIntoString(String::empty);
            }
        }

        massLine << ")";
        if(tagName.compare("port") != 0)
        {
            massLine << " :";
            massLine << tagName << "(";
            XmlElement* params = c->getChildByName("parameters");
            StringArray paramsStr;
            if (params != nullptr)
            {
                forEachXmlChildElement(*params, c2)
                {
                    paramsStr.add(c2->getStringAttribute("value"));
                }
            }
            massLine << paramsStr.joinIntoString(",") << ")";
        }
        massLine << ";";
        massobjects.add(massLine);
    }

    StringArray audioobjects;
    StringArray audioNames;
    forEachXmlChildElement(*audioouts, c)
    {
        String audioLine;
        String audioName = c->getStringAttribute("identifier");
        audioNames.add(audioName);
        audioLine << "\t";
        audioLine << audioName << " = ";
        XmlElement* params = c->getChildByName("sources");
        StringArray paramsStr;
        if(params->getNumChildElements() > 0)
        {
            forEachXmlChildElement(*params, c2)
            {
                paramsStr.add(c2->getStringAttribute("value"));
            }
            audioLine << paramsStr.joinIntoString("+");
        }
        String optional = c->getStringAttribute("optional");
        if(optional != String::empty)
            audioLine << " : " << optional;
        audioLine << ";";
        audioobjects.add(audioLine);
    }

    StringArray inputs;
    for (int i = 0; i < massLinkRefs.size(); ++i)
    {
        inputs.add(massLinkRefs[i]->massId);
    }

    StringArray outputs = inputs;
    outputs.addArray(audioNames);

    StringArray inputsP;
    for (int i = 0; i < inputs.size(); ++i)
    {
        String inputP = inputs[i];
        inputP << "p";
        inputsP.add(inputP);
    }

    dspContent << "bigBlock(" << inputsP.joinIntoString(",") << ") = (";
    dspContent << outputs.joinIntoString(",") << ") with {\n";
    dspContent << "\n\t//waveguide termination objects\n";
    dspContent << "\t" << wgTermString << "\n";
    dspContent << "\n\t//junctions\n";
    dspContent << "\t" << junctString << "\n";
    dspContent << "\n\t//mass-like objects\n";
    dspContent << massobjects.joinIntoString("\n") << "\n";
    dspContent << "\n\t//link-like objects\n";
    dspContent << linkobjects.joinIntoString("\n") << "\n";
    dspContent << "\n\t//audio objects\n";
    dspContent << audioobjects.joinIntoString("\n") << "\n};\n\n";

    StringArray feedbackArray;
    StringArray outputArray;
    for (int i = 0; i < numMasslike - numPorts + 2 * numWaveguides; ++i)
    {
        feedbackArray.add("_");
        outputArray.add("!");
    }
    for (int i = 0; i < numPorts+audioNames.size(); ++i)
    {
        feedbackArray.add("!");
        outputArray.add("_");
    }
    dspContent << "process = (bigBlock)~(";
    dspContent << feedbackArray.joinIntoString(",");
    dspContent << "):(";
    dspContent << outputArray.joinIntoString(",") << ");";

    massLinkRefs.clear();
    DBG(dspContent);

    return dspContent;
}

bool writeStringToFile(const String& s, const String& p)
{
    File outFile;
    if(File::isAbsolutePath(p))
        outFile = p;
    else
        outFile = File::getCurrentWorkingDirectory().getChildFile(p);
    
    TemporaryFile temp(outFile);

    ScopedPointer <FileOutputStream> out(temp.getFile().createOutputStream());

    if (out != nullptr)
    {
        out->write(s.toUTF8(), s.getNumBytesAsUTF8());
        out = nullptr; // (deletes the stream)

        bool succeeded = temp.overwriteTargetFileWithTemporary();
        return succeeded;
    }
    else
    {
        return false;
    }
}
//==============================================================================
int main (int argc, char* argv[])
{
    StringArray args;
    for (int i = 1; i < argc; ++i)
    {
        args.addTokens(argv[i], true);
        args[i];
    }
    args.trim();
    if(args.size() != 2)
    {
        return showHelp();
    }

    File in;
    if(File::isAbsolutePath(args[0]))
        in = args[0];
    else
        in = File::getCurrentWorkingDirectory().getChildFile(args[0]);

    if(! in.existsAsFile())
    {
        std::cout << "Input file: " << in.getFullPathName().toUTF8().getAddress();
        std::cout << " does not exist" << std::endl;
        return 1;
    }
    
    XmlElement* mdl = XmlDocument::parse(in);

    String dspString = generateDspString(*mdl);

    delete mdl;

//    if(writeStringToFile(dspString, args[1]))
    if(true)
        return 0;
    else
        return 1;
}
