/*
  ==============================================================================

  Synth-A-Modeler compiler (c++ version)
  Author: Peter Vasil (code), Edgar Berdahl (method)

  ==============================================================================

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software Foundation,
  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

*/

#include "../JuceLibraryCode/JuceHeader.h"


struct MassLinkRef
{
    String massId;
    StringArray linkRefs;
};

int containsMassLinkRef(std::vector<MassLinkRef> mlf, const String& mId)
{
    for (int i = 0; i < mlf.size(); ++i)
    {
        MassLinkRef m = mlf[i];
        if(m.massId.compare(mId) == 0)
            return i;
    }
    return -1;
}
int showHelp()
{
    std::cout << "Synth-A-Modeler!" << std::endl
        << std::endl
        << "Usage: " << std::endl
        << std::endl
        << " Synth-A-Modeler /path/to/inputfile.mdlx"
        << " /path/to/outputfile.dsp" << std::endl
        << std::endl;

    return 0;
}

String generateDspString(const XmlElement& xml)
{
    String dspContent;

    dspContent << "// This DSP file has been generated by the Synth-A-Modeler compiler.\n";
    dspContent << "import(\"physicalmodeling.lib\");\n\n";

    XmlElement* faustcode = xml.getChildByName("variables");
    XmlElement* masses = xml.getChildByName("masses");
    XmlElement* links = xml.getChildByName("links");
    XmlElement* waveguides = xml.getChildByName("waveguides");
    XmlElement* terminations = xml.getChildByName("terminations");
    XmlElement* junctions = xml.getChildByName("junctions");
    XmlElement* audioouts = xml.getChildByName("audioobjects");

    int numMasslike = 0;
    int numPorts = 0;
    int numWaveguides = 0;
    // Write all faustcode
    forEachXmlChildElementWithTagName(*faustcode, c, "variable")
    {
        dspContent << c->getStringAttribute("identifier");
        dspContent << "=";
        dspContent << c->getStringAttribute("faustCode");
        dspContent << ";\n";
    }
    dspContent << "\n";

//    HashMap<String, StringArray> massLinks;
    std::vector<MassLinkRef> massLinkRefs;
    forEachXmlChildElement(*masses, c)
    {
        MassLinkRef mlf;
        mlf.massId = c->getStringAttribute("identifier");
        StringArray mlfa;
        mlf.linkRefs = mlfa;
        massLinkRefs.push_back(mlf);
    }
    StringArray linkobjects;
    forEachXmlChildElement(*links, c)
    {
        String linkLine;
        linkLine << "\t";
        String linkId = c->getStringAttribute("identifier");
        linkLine << linkId;
        linkLine << " = (";
        String startVertex = c->getStringAttribute("startVertex");
        String endVertex = c->getStringAttribute("endVertex");

        int sIdx = containsMassLinkRef(massLinkRefs, startVertex);
        if(sIdx >= 0)
            massLinkRefs[sIdx].linkRefs.add("-"+linkId);

        int eIdx = containsMassLinkRef(massLinkRefs, endVertex);
        if(eIdx >= 0)
            massLinkRefs[eIdx].linkRefs.add("+"+linkId);

        linkLine << startVertex << "p - ";
        linkLine << endVertex << "p) : ";
        linkLine << c->getTagName() << "(";
        XmlElement* params = c->getChildByName("parameters");
        StringArray paramsStr;
        forEachXmlChildElement(*params, c2)
        {
            paramsStr.add(c2->getStringAttribute("value"));
        }
        linkLine << paramsStr.joinIntoString(",") << ");";
        linkobjects.add(linkLine);
    }
    StringArray massobjects;
    forEachXmlChildElement(*masses, c)
    {
        ++numMasslike;
        String massLine;
        String tagName = c->getTagName();
        massLine << "\t";
        String massName = c->getStringAttribute("identifier");
        massLine << massName << " = (0.0";
        if(tagName.compare("port") == 0)
            ++numPorts;

        int mIdx = containsMassLinkRef(massLinkRefs, massName);
        if(mIdx >= 0)
        {
            if(massLinkRefs[mIdx].linkRefs.size() > 0)
            {
                massLine << massLinkRefs[mIdx].linkRefs.joinIntoString(String::empty);
            }
        }

        massLine << ")";
        if(tagName.compare("port") != 0)
        {
            massLine << " :";
            massLine << tagName << "(";
            XmlElement* params = c->getChildByName("parameters");
            StringArray paramsStr;
            if (params != nullptr)
            {
                forEachXmlChildElement(*params, c2)
                {
                    paramsStr.add(c2->getStringAttribute("value"));
                }
            }
            massLine << paramsStr.joinIntoString(",") << ")";
        }
        massLine << ";";
        massobjects.add(massLine);
    }

    StringArray audioobjects;
    StringArray audioNames;
    forEachXmlChildElement(*audioouts, c)
    {
        String audioLine;
        String audioName = c->getStringAttribute("identifier");
        audioNames.add(audioName);
        audioLine << "\t";
        audioLine << audioName << " = ";
        XmlElement* params = c->getChildByName("sources");
        StringArray paramsStr;
        if(params->getNumChildElements() > 0)
        {
            forEachXmlChildElement(*params, c2)
            {
                paramsStr.add(c2->getStringAttribute("value"));
            }
            audioLine << paramsStr.joinIntoString("+");
        }
        String optional = c->getStringAttribute("optional");
        if(optional != String::empty)
            audioLine << " : " << optional;
        audioLine << ";";
        audioobjects.add(audioLine);
    }

    StringArray inputs;
    for (int i = 0; i < massLinkRefs.size(); ++i)
    {
        inputs.add(massLinkRefs[i].massId);
    }

    StringArray outputs = inputs;
    outputs.addArray(audioNames);

    StringArray inputsP;
    for (int i = 0; i < inputs.size(); ++i)
    {
        String inputP = inputs[i];
        inputP << "p";
        inputsP.add(inputP);
    }

    dspContent << "bigBlock(" << inputsP.joinIntoString(",") << ") = (";
    dspContent << outputs.joinIntoString(",") << ") with {\n";
    dspContent << "\n\t//mass-like objects\n";
    dspContent << massobjects.joinIntoString("\n") << "\n";
    dspContent << "\n\t//link-like objects\n";
    dspContent << linkobjects.joinIntoString("\n") << "\n";
    dspContent << "\n\t//audio objects\n";
    dspContent << audioobjects.joinIntoString("\n") << "\n};\n\n";

    StringArray feedbackArray;
    StringArray outputArray;
    for (int i = 0; i < numMasslike - numPorts; ++i)
    {
        feedbackArray.add("_");
        outputArray.add("!");
    }
    for (int i = 0; i < numPorts+audioNames.size(); ++i)
    {
        feedbackArray.add("!");
        outputArray.add("_");
    }
    dspContent << "process = (bigBlock)~(";
    dspContent << feedbackArray.joinIntoString(",");
    dspContent << "):(";
    dspContent << outputArray.joinIntoString(",") << ");";

    DBG(dspContent);

    return dspContent;
}

bool writeStringToFile(const String& s, const String& p)
{
    File outFile;
    if(File::isAbsolutePath(p))
        outFile = p;
    else
        outFile = File::getCurrentWorkingDirectory().getChildFile(p);
    
    TemporaryFile temp(outFile);

    ScopedPointer <FileOutputStream> out(temp.getFile().createOutputStream());

    if (out != nullptr)
    {
        out->write(s.toUTF8(), s.getNumBytesAsUTF8());
        out = nullptr; // (deletes the stream)

        bool succeeded = temp.overwriteTargetFileWithTemporary();
        return succeeded;
    }
    else
    {
        return false;
    }
}
//==============================================================================
int main (int argc, char* argv[])
{
    StringArray args;
    for (int i = 1; i < argc; ++i)
    {
        args.addTokens(argv[i], true);
        args[i];
    }
    args.trim();
    if(args.size() != 2)
    {
        return showHelp();
    }

    File in;
    if(File::isAbsolutePath(args[0]))
        in = args[0];
    else
        in = File::getCurrentWorkingDirectory().getChildFile(args[0]);

    if(! in.existsAsFile())
    {
        std::cout << "Input file: " << in.getFullPathName().toUTF8().getAddress();
        std::cout << " does not exist" << std::endl;
        return 1;
    }
    
    XmlElement* mdl = XmlDocument::parse(in);

    String dspString = generateDspString(*mdl);

    delete mdl;

    if(writeStringToFile(dspString, args[1]))
        return 0;
    else
        return 1;
}
